package com.tutorial.redis.module07.adapter.outbound.redis;

import com.tutorial.redis.module07.domain.model.StreamMessage;
import com.tutorial.redis.module07.domain.port.outbound.StreamProducerPort;
import org.springframework.data.domain.Range;
import org.springframework.data.redis.connection.stream.MapRecord;
import org.springframework.data.redis.connection.stream.ReadOffset;
import org.springframework.data.redis.connection.stream.StreamOffset;
import org.springframework.data.redis.connection.stream.StreamReadOptions;
import org.springframework.data.redis.connection.stream.StreamRecords;
import org.springframework.data.redis.core.StreamOperations;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Redis Stream producer adapter for basic stream operations.
 *
 * <p>Implements {@link StreamProducerPort} using {@link StreamOperations} from
 * Spring Data Redis, providing XADD, XREAD, XRANGE, and XTRIM functionality.</p>
 *
 * <p>All stream entries are stored as {@code Map<String, String>} field-value
 * pairs, consistent with the Redis Stream data model. Message IDs are
 * auto-generated by Redis in the format {@code <millisecondsTime>-<sequenceNumber>}.</p>
 */
@Component
public class RedisStreamProducerAdapter implements StreamProducerPort {

    private final StringRedisTemplate stringRedisTemplate;

    public RedisStreamProducerAdapter(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    /**
     * Appends a new entry to the specified stream via {@code XADD}.
     *
     * @param streamKey the stream key
     * @param fields    the field-value pairs for the entry
     * @return the auto-generated message ID (e.g. "1609459200000-0")
     */
    @Override
    public String addToStream(String streamKey, Map<String, String> fields) {
        MapRecord<String, String, String> record = StreamRecords
                .<String, String, String>mapBacked(fields)
                .withStreamKey(streamKey);

        return stringRedisTemplate.opsForStream()
                .add(record)
                .getValue();
    }

    /**
     * Reads messages from a stream starting after the given message ID via {@code XREAD}.
     *
     * @param streamKey the stream key
     * @param fromId    the message ID to read after (use "0-0" for all)
     * @param count     the maximum number of messages to return
     * @return a list of stream messages
     */
    @Override
    public List<StreamMessage> readMessages(String streamKey, String fromId, int count) {
        StreamReadOptions options = StreamReadOptions.empty().count(count);

        List<MapRecord<String, Object, Object>> records = stringRedisTemplate.opsForStream()
                .read(options, StreamOffset.create(streamKey, ReadOffset.from(fromId)));

        if (records == null || records.isEmpty()) {
            return Collections.emptyList();
        }

        return records.stream()
                .map(record -> mapToStreamMessage(record, streamKey))
                .toList();
    }

    /**
     * Reads messages within a range of message IDs via {@code XRANGE}.
     *
     * @param streamKey the stream key
     * @param fromId    the start message ID (inclusive, use "-" for earliest)
     * @param toId      the end message ID (inclusive, use "+" for latest)
     * @return a list of stream messages in the range
     */
    @Override
    public List<StreamMessage> rangeMessages(String streamKey, String fromId, String toId) {
        List<MapRecord<String, Object, Object>> records = stringRedisTemplate.opsForStream()
                .range(streamKey, Range.closed(fromId, toId));

        if (records == null || records.isEmpty()) {
            return Collections.emptyList();
        }

        return records.stream()
                .map(record -> mapToStreamMessage(record, streamKey))
                .toList();
    }

    /**
     * Trims the stream to at most the specified length via {@code XTRIM MAXLEN}.
     *
     * @param streamKey the stream key
     * @param maxLen    the maximum number of entries to retain
     */
    @Override
    public void trimStream(String streamKey, long maxLen) {
        stringRedisTemplate.opsForStream().trim(streamKey, maxLen);
    }

    /**
     * Converts a Spring Data Redis {@link MapRecord} into a domain {@link StreamMessage}.
     */
    private StreamMessage mapToStreamMessage(MapRecord<String, Object, Object> record, String streamKey) {
        String messageId = record.getId().getValue();

        Map<String, String> payload = new LinkedHashMap<>();
        record.getValue().forEach((key, value) ->
                payload.put(String.valueOf(key), String.valueOf(value)));

        Instant timestamp = extractTimestamp(messageId);

        return new StreamMessage(messageId, streamKey, payload, timestamp);
    }

    /**
     * Extracts the timestamp from a Redis Stream message ID.
     * Message IDs have the format {@code <millisecondsTime>-<sequenceNumber>}.
     */
    private Instant extractTimestamp(String messageId) {
        try {
            String millisPart = messageId.split("-")[0];
            return Instant.ofEpochMilli(Long.parseLong(millisPart));
        } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
            return Instant.now();
        }
    }
}
